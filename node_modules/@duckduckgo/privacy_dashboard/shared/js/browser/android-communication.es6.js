import { setupColorScheme, concatParams } from './common.es6'

const convertTrackerDataPayload = (tabUrl, upgradedHttps, allowlisted, data) => {
    const trackers = data.trackers || {}
    const trackersBlocked = data.trackerBlocked || {}
    const tabDomain = (new URL(tabUrl).host).replace(/^www\./, '')

    return {
        url: tabUrl,
        status: 'complete',
        upgradedHttps,
        site: {
            url: tabUrl,
            domain: tabDomain,
            allowlisted,
            enabledFeatures: ['contentBlocking']
        },
        trackers,
        trackersBlocked
    }
}

let channel = null
const backgroundMessage = (backgroundModel) => {
    channel = backgroundModel
}

const setColorScheme = setupColorScheme()

const getBackgroundTabDataPromises = []
let trackerBlockingData
let permissionsData
let certificateData
let upgradedHttps
let isProtected
let isPendingUpdates
let parentEntity
let consentManaged

const combineSources = () => ({
    tab: Object.assign(
        {
            isPendingUpdates,
            parentEntity,
            consentManaged
        },
        trackerBlockingData || {},
        permissionsData ? { permissions: permissionsData } : {},
        certificateData ? { certificate: certificateData } : {}
    )
})

const resolveInitialRender = function () {
    const isUpgradedHttpsSet = typeof upgradedHttps === 'boolean'
    const isIsProtectedSet = typeof isProtected === 'boolean'
    const isTrackerBlockingDataSet = typeof trackerBlockingData === 'object'
    if (!isUpgradedHttpsSet || !isIsProtectedSet || !isTrackerBlockingDataSet) {
        return
    }

    getBackgroundTabDataPromises.forEach((resolve) => resolve(combineSources()))
    channel?.send('updateTabData')
}

// Change handlers
// -----------------------------------------------------------------------------

window.onChangeTheme = function (themeName) {
    setColorScheme(themeName)
}

window.onChangeTrackerBlockingData = function (tabUrl, rawTrackerBlockingData) {
    trackerBlockingData = convertTrackerDataPayload(tabUrl, upgradedHttps, !isProtected, rawTrackerBlockingData)
    resolveInitialRender()
}

window.onChangeAllowedPermissions = function (data) {
    permissionsData = data
    channel?.send('updateTabData')
}

window.onChangeUpgradedHttps = function (data) {
    upgradedHttps = data

    if (trackerBlockingData) trackerBlockingData.upgradedHttps = upgradedHttps
    resolveInitialRender()
}

window.onChangeProtectionStatus = function (data) {
    isProtected = data

    if (trackerBlockingData) trackerBlockingData.site.allowlisted = !isProtected
    resolveInitialRender()
}

window.onChangeCertificateData = function (data) {
    certificateData = data.secCertificateViewModels
    channel?.send('updateTabData')
}

window.onIsPendingUpdates = function (data) {
    isPendingUpdates = data
    channel?.send('updateTabData')
}

window.onChangeParentEntity = function (data) {
    parentEntity = data
    channel?.send('updateTabData')
}

window.onChangeConsentManaged = function (data) {
    consentManaged = data
    channel?.send('updateTabData')
}

// -----------------------------------------------------------------------------

function getAdditionalParams () {
    const browser = 'macos_desktop'
    const queryStringParams = {}
    const result = [browser, queryStringParams]

    return result
}

const fetch = (message) => {
    if (!window.PrivacyDashboard) {
        console.error('window.PrivacyDashboard not available')
        return
    }

    if (message.setList) {
        const { list, value } = message.setList
        if (list !== 'allowlisted') {
            console.warn('only `allowlisted` is currently supported on android')
            return
        }

        // `allowlisted: true` means the user disabled protections.
        // so `isProtected` is the opposite of `allowlisted`.
        const isProtected = value === false

        window.PrivacyDashboard.toggleAllowlist(isProtected)

        // Call as if this was an outside change. This will trigger events to
        // have all models re-request data from background state.
        window.onChangeProtectionStatus(isProtected)
    }

    if (message.updatePermission) {
        window.PrivacyDashboard.updatePermission({
            permission: message.updatePermission.id,
            value: message.updatePermission.value
        })
    }

    if (message.closePrivacyDashboard) {
        window.PrivacyDashboard.close()
    }

    if (message.checkBrokenSiteReportHandled) {
        window.PrivacyDashboard.showBreakageForm()
        return true // Return true to prevent HTML form from showing
    }

    if (message.firePixel) {
        const pixelName = message.firePixel[0]

        // Only allow broken site reports
        if (pixelName !== 'epbf') return

        const args = message.firePixel.slice(1).concat(getAdditionalParams())
        const paramString = concatParams(args)

        // Pass to native to send request
        window.PrivacyDashboard.firePixel(`${pixelName}${paramString}`)
    }
}

const getBackgroundTabData = () => {
    return new Promise((resolve) => {
        if (trackerBlockingData) {
            resolve(combineSources())
            return
        }

        getBackgroundTabDataPromises.push(resolve)
    })
}

module.exports = {
    fetch: fetch,
    backgroundMessage: backgroundMessage,
    getBackgroundTabData: getBackgroundTabData
}
