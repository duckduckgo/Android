import { setupColorScheme } from './common.es6'

const parseUserAgentString = require('../shared-utils/parse-user-agent-string.es6')
const browserInfo = parseUserAgentString()

let channel
let isPendingUpdates = false

setupColorScheme()

export function fetch (message) {
    // ensure the HTML form is shown for the extension
    if (message.checkBrokenSiteReportHandled) {
        return false
    }
    return new Promise((resolve, reject) => {
        if (message.setList) {
            message = {
                messageType: 'setList',
                options: message.setList
            }
        }
        if (message.postToggleAllowlist) {
            postToggleAllowlist(message.postToggleAllowlist.id)
            return
        }
        if (Array.isArray(message.firePixel)) {
            if (message.firePixel[0] === 'epbf') {
                message = {
                    messageType: 'submitBrokenSiteReport',
                    options: message.firePixel.slice(1) // remove initial 'epbf' string
                }
            } else {
                console.warn('extension cannot handle this firePixel message')
                return
            }
        }
        chrome.runtime.sendMessage(message, (result) => resolve(result))
    })
}

export function backgroundMessage (_channel) {
    channel = _channel
    // listen for messages from background and
    // notify subscribers
    chrome.runtime.onMessage.addListener((req, sender) => {
        if (sender.id !== chrome.runtime.id) return
        if (req.allowlistChanged) {
            // force the toggles or any other UI to go into a 'pending state'
            isPendingUpdates = true
            channel.send('updateTabData')
        }
        if (req.updateTabData) channel.send('updateTabData')
        // todo(Shane): verify if these are both still needed?
        if (req.didResetTrackersData) channel.send('didResetTrackersData', req.didResetTrackersData)
        if (req.closePopup) window.close()
    })
}

export async function getBackgroundTabData () {
    const resp = await fetch({ messageType: 'getPrivacyDashboardData' })
    if (!resp?.tab) {
        console.warn('could not fetch tab...')
        return {}
    }
    const { tab, emailProtectionUserData } = resp
    const response = {
        tab: {
            ...tab,
            ctaScreens: {}, // supports CTA feature
            search: {}, // supports Search feature
            emailProtection: {}, // supports email protection
            isPendingUpdates
        },
        emailProtectionUserData
    }
    return response
}

const getExtensionURL = (path) => {
    return window.chrome.runtime.getURL(path)
}

const openExtensionPage = (path) => {
    window.chrome.tabs.create({ url: getExtensionURL(path) })
}

export const openOptionsPage = (browser) => {
    if (browser === 'moz') {
        openExtensionPage('/html/options.html')
        window.close()
    } else {
        window.chrome.runtime.openOptionsPage()
    }
}

export const search = (url) => {
    window.chrome.tabs.create({ url: `https://duckduckgo.com/?q=${url}&bext=${browserInfo.os}cr` })
}

const reloadTab = (id) => {
    window.chrome.tabs.reload(id)
}

const closePopup = () => {
    const w = window.chrome.extension.getViews({ type: 'popup' })[0]
    w.close()
}

export const openNewTab = (url) => {
    window.chrome.tabs.create({ url })
}

const postToggleAllowlist = (tabId) => {
    setTimeout(() => {
        reloadTab(tabId)
        closePopup()
    }, 500)
}
