package com.duckduckgo.autofill.impl.configuration.integration.modern.listener.password

import android.webkit.WebView
import androidx.core.net.toUri
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.webkit.JavaScriptReplyProxy
import androidx.webkit.WebMessageCompat
import com.duckduckgo.autofill.api.passwordgeneration.AutomaticSavedLoginsMonitor
import com.duckduckgo.autofill.impl.InternalAutofillCapabilityChecker
import com.duckduckgo.autofill.impl.configuration.integration.modern.listener.TestWebMessageListenerCallback
import com.duckduckgo.autofill.impl.jsbridge.request.AutofillRequestParser
import com.duckduckgo.autofill.impl.jsbridge.request.AutofillStoreFormDataCredentialsRequest
import com.duckduckgo.autofill.impl.jsbridge.request.AutofillStoreFormDataRequest
import com.duckduckgo.autofill.impl.store.InternalAutofillStore
import com.duckduckgo.autofill.impl.store.NeverSavedSiteRepository
import com.duckduckgo.autofill.impl.systemautofill.SystemAutofillServiceSuppressor
import com.duckduckgo.autofill.impl.ui.credential.passwordgeneration.Actions
import com.duckduckgo.autofill.impl.ui.credential.passwordgeneration.AutogeneratedPasswordEventResolver
import com.duckduckgo.common.test.CoroutineTestRule
import kotlinx.coroutines.test.runTest
import org.junit.Assert.assertEquals
import org.junit.Assert.assertNotNull
import org.junit.Assert.assertNull
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.kotlin.any
import org.mockito.kotlin.anyOrNull
import org.mockito.kotlin.mock
import org.mockito.kotlin.whenever

@RunWith(AndroidJUnit4::class)
class WebMessageListenerStoreFormDataTest {

    private val testCallback = TestWebMessageListenerCallback()
    private val mockWebView: WebView = mock()
    private val webMessageReply: JavaScriptReplyProxy = mock()
    private val systemAutofillServiceSuppressor: SystemAutofillServiceSuppressor = mock()
    private val passwordEventResolver: AutogeneratedPasswordEventResolver = mock()
    private val autofillStore: InternalAutofillStore = mock()
    private val autoSavedLoginsMonitor: AutomaticSavedLoginsMonitor = mock()
    private val requestParser: AutofillRequestParser = mock()
    private val neverSavedSiteRepository: NeverSavedSiteRepository = mock()
    private val autofillCapabilityChecker: InternalAutofillCapabilityChecker = mock()

    @get:Rule
    val coroutineTestRule: CoroutineTestRule = CoroutineTestRule()

    private val testee = WebMessageListenerStoreFormData(
        appCoroutineScope = coroutineTestRule.testScope,
        dispatchers = coroutineTestRule.testDispatcherProvider,
        autofillCapabilityChecker = autofillCapabilityChecker,
        neverSavedSiteRepository = neverSavedSiteRepository,
        requestParser = requestParser,
        autoSavedLoginsMonitor = autoSavedLoginsMonitor,
        autofillStore = autofillStore,
        passwordEventResolver = passwordEventResolver,
        systemAutofillServiceSuppressor = systemAutofillServiceSuppressor,
    )

    @Before
    fun setup() = runTest {
        testee.callback = testCallback
        testee.tabId = "abc-123"
        whenever(mockWebView.url).thenReturn(REQUEST_URL)
        whenever(autofillCapabilityChecker.isAutofillEnabledByConfiguration(any())).thenReturn(true)
        whenever(autofillCapabilityChecker.canSaveCredentialsFromWebView(any())).thenReturn(true)
        whenever(neverSavedSiteRepository.isInNeverSaveList(any())).thenReturn(false)
        whenever(autoSavedLoginsMonitor.getAutoSavedLoginId(any())).thenReturn(null)
    }

    @Test
    fun whenStoreFormDataCalledWithNoPasswordThenCallbackInvoked() = runTest {
        configureRequestParserToReturnSaveCredentialRequestType(username = "dax@duck.com", password = null)
        simulateWebMessage()
        assertNotNull(testCallback.credentialsToSave)
        assertEquals("dax@duck.com", testCallback.credentialsToSave!!.username)
    }

    @Test
    fun whenStoreFormDataCalledWithNullUsernameAndPasswordThenCallbackNotInvoked() = runTest {
        configureRequestParserToReturnSaveCredentialRequestType(username = null, password = null)
        simulateWebMessage()
        assertNull(testCallback.credentialsToSave)
    }

    @Test
    fun whenStoreFormDataCalledWithBlankUsernameThenCallbackInvoked() = runTest {
        configureRequestParserToReturnSaveCredentialRequestType(username = " ", password = "password")
        simulateWebMessage()
        assertEquals(" ", testCallback.credentialsToSave!!.username)
        assertEquals("password", testCallback.credentialsToSave!!.password)
    }

    @Test
    fun whenStoreFormDataCalledWithBlankPasswordThenCallbackInvoked() = runTest {
        configureRequestParserToReturnSaveCredentialRequestType(username = "username", password = " ")
        simulateWebMessage()
        assertEquals("username", testCallback.credentialsToSave!!.username)
        assertEquals(" ", testCallback.credentialsToSave!!.password)
    }

    @Test
    fun whenStoreFormDataCalledButSiteInNeverSaveListThenCallbackNotInvoked() = runTest {
        configureRequestParserToReturnSaveCredentialRequestType(username = "username", password = "password")
        whenever(neverSavedSiteRepository.isInNeverSaveList(any())).thenReturn(true)
        simulateWebMessage()
        assertNull(testCallback.credentialsToSave)
    }

    @Test
    fun whenStoreFormDataCalledWithBlankUsernameAndBlankPasswordThenCallbackNotInvoked() = runTest {
        configureRequestParserToReturnSaveCredentialRequestType(username = " ", password = " ")
        simulateWebMessage()
        assertNull(testCallback.credentialsToSave)
    }

    @Test
    fun whenStoreFormDataCalledAndParsingErrorThenExceptionIsContained() = runTest {
        configureRequestParserToReturnSaveCredentialRequestType(username = "username", password = "password")
        whenever(requestParser.parseStoreFormDataRequest(any())).thenReturn(Result.failure(RuntimeException("Parsing error")))
        simulateWebMessage()
        assertNull(testCallback.credentialsToSave)
    }

    @Test
    fun whenStoreFormDataCalledWithNoUsernameThenCallbackInvoked() = runTest {
        configureRequestParserToReturnSaveCredentialRequestType(username = null, password = "password")
        simulateWebMessage()
        assertNotNull(testCallback.credentialsToSave)
    }

    private suspend fun configureRequestParserToReturnSaveCredentialRequestType(
        username: String?,
        password: String?,
    ) {
        val credentials = AutofillStoreFormDataCredentialsRequest(username = username, password = password)
        val topLevelRequest = AutofillStoreFormDataRequest(credentials)
        whenever(requestParser.parseStoreFormDataRequest(any())).thenReturn(Result.success(topLevelRequest))
        whenever(passwordEventResolver.decideActions(anyOrNull(), any())).thenReturn(listOf(Actions.PromptToSave))
    }

    private fun simulateWebMessage(isMainFrame: Boolean = true) {
        testee.onPostMessage(
            webView = mockWebView,
            message = WebMessageCompat(""),
            sourceOrigin = REQUEST_ORIGIN,
            isMainFrame = isMainFrame,
            reply = webMessageReply,
        )
    }

    companion object {
        private const val REQUEST_URL = "https://example.com"
        private val REQUEST_ORIGIN = REQUEST_URL.toUri()
    }
}
